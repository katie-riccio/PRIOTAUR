---
title: "Plant Science Research Project Notebook"
author: "Katie Riccio"
output: 
  html_notebook: 
    toc: true
  html_document:
    theme: flatly
    toc: true 
    toc_float:
      collapsed: false
runtime: shiny
---

This is my notebook for my honours research project.

# Setup

Loading libraries:

```{r libraries}
library(bslib)
library(echo.find)
library(ggplot2)
library(ggbreak)
library(ggnewscale) # for setting colour palette
library(ggrepel) # for repelling labels
library(shiny)
library(shinycssloaders)
library(plotly)
library(rain)
library(readxl)
library(tidyverse)
library(viridis)
library(writexl)
library(zoo) # for interpolation
```

Setting global options for the document:

```{r chunk-options, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE
)
```

Creating the time-of-day shading for all subsequent graphs to use:

```{r time-shading}
time_shading <- tibble(Time = seq(0, 122, 1)) %>%
  mutate(
    Condition = case_when(Time <= 24 ~ "LD", Time >= 48 ~ "LL"),
    ToD = case_when(
      ((Time %/% 12) %% 2) == 1 & Condition == "LD" ~ "Night",
      ((Time %/% 12) %% 2) == 1 & Condition == "LL" ~ "Subjective night",
      ((Time %/% 12) %% 2) == 0 ~ "Day"
    ),
    colour = case_when(
      ToD == "Day" ~ "#ffffff",
      ToD == "Night" ~ "#a5a5a5",
      ToD == "Subjective night" ~ "#e5e5e5"
    )
  ) %>% drop_na() # set up graph background 
time_shading

time_plot <- tibble(Time = seq(0,122,1),
                    Value = Time%%10) # create dummy table to plot

time_graph <- ggplot(data = time_plot, aes(x = Time, y = Value)) +
  geom_rect(data = time_shading,
                aes(y = NULL, group = NULL,
                    xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, 
                    fill = colour), 
                show.legend = FALSE) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # let rest of graph use new shading 
  
  geom_point(alpha = 0.5) # plot dummy table

time_graph # test that it works
```

------------------------------------------------------------------------

# Protein exploration

The deep-coverage proteome data was initially published in [Kay *et al.* (2021)](https://doi.org/10.1038/s42003-021-02680-3), and my tool makes use of the original dataset plus a smaller table of the calculated *p*-values for rhythmicity by eJTK, RAIN, and ECHO under LD and LL conditions.

Loading and viewing initial files:

```{r load-protein-data}
nuc_proteome <- read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", sheet = 2, na = "ND", .name_repair = function(x) gsub("\\s+", "_", x)) # nuclear-encoded proteome data

org_proteome <- read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", sheet = 3, na = "ND", .name_repair = function(x) gsub("\\s+", "_", x)) # organellar-encoded proteome data

nuc_proteome # check nuclear proteome
org_proteome # check organellar proteome
tail(org_proteome)
```

Once these were loaded in, I realised that the organellar proteome lacked *p*-values for RAIN and ECHO, so I calculated these myself for better comparison with the ions (as their rhythmicity was going to be assessed using these two methods, not eJTK).

## Organelle proteome rhythmicity analysis

```{r load-organellar-abundance}
org_abundance <- bind_cols(
  read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", 
             sheet = 3, range = cell_cols("A")), # identifiers
  read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", 
             sheet = 3, range = cell_cols("H:O")), # LD abundance
  read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", 
             sheet = 3, range = cell_cols("W:AR")) # LL abundance
) # identifier and abundance values from existing data - have to bind because read_excel doesn't take non-congruous column ranges

org_abundance # check abundance values
tail(org_abundance) # check tail to spot NAs
```

### RAIN

```{r org-rain-calculations}
org_rain_table <- pivot_longer(org_abundance, cols = -Identifier,
                              names_to = "Time", names_transform = as.numeric,
                              values_to = "Abundance") %>%
  pivot_wider(names_from = "Identifier", values_from = "Abundance")
org_rain_table

### LD ----

org_rain_LD <- filter(org_rain_table, Time < 48) %>% select(!Time) %>% as.matrix() %>%
  rain(period = 24, period.delta = 0, method = "independent", na.rm = TRUE, # 24-hour periods only
       deltat = 3.5, nr.series = 1, verbose = TRUE) %>%
  rename(LD_rain = pVal) %>% rownames_to_column("Identifier")

org_rain_LD

### LL ----
org_rain_LL <- filter(org_rain_table, Time >= 48) %>% select(!Time) %>% as.matrix() %>%
  rain(period = 24, period.delta = 4, method = "longitudinal", na.rm = TRUE, # 20- to 28-hour periods
    deltat = 3.5, nr.series = 1, verbose = TRUE) %>% 
  rename(LL_rain = pVal) %>% rownames_to_column("Identifier")

org_rain_LL # in theory this should be accurate

sig_rain_LL <- filter(org_rain_LL, LL_rain < 0.05) # filter at p < 0.05 threshold
sig_rain_LL # 29 organellar proteins are rhythmic in LL according to RAIN
```

This identifies 29 significantly-rhythmic organelle-derived proteins.

### ECHO

```{r org-echo-calculations}
org_echo_table <- org_abundance %>% drop_na() # ECHO doesn't like NAs
org_echo_table

### LD ----
org_echo_LD <- select(org_echo_table, Identifier, "0":"24.5") %>%
  echo_find(begin = 0, end = 24.5,
            resol = 3.5, num_reps = 1, 
            low = 24, high = 24, is_de_linear_trend = FALSE,
            paired = FALSE, rem_unexpr = FALSE, is_normal = FALSE, 
            is_smooth = FALSE, run_all_per = FALSE) %>%
  rename(Identifier = "Gene Name", LD_echo = "P-Value")

select(org_echo_LD, "Identifier", "LD_echo":"BY Adj P-Value")


### LL ----
org_echo_LL <- select(org_echo_table, Identifier, "48":"121.5") %>%
echo_find(begin = 48, end = 121.5,
          resol = 3.5, num_reps = 1, 
          low = 20, high = 28, is_de_linear_trend = TRUE,
          paired = FALSE, rem_unexpr = FALSE, is_normal = FALSE, 
          is_smooth = FALSE, run_all_per = FALSE) %>%
  rename(Identifier = "Gene Name", LL_echo = "P-Value")

select(org_echo_LL, "Identifier", "LL_echo":"BY Adj P-Value")

sig_echo_LL <- filter(org_echo_LL, LL_echo < 0.05) # filter at p < 0.05 threshold
select(sig_echo_LL, "Identifier", "LL_echo":"BY Adj P-Value") # 34 organellar proteins are rhythmic in LL according to ECHO

```

This identifies 34 significantly-rhythmic organelle-derived proteins. 5 proteins could not have values calculated due to containing blank cells.

### Saving/loading results

The results of these were then saved to file.

```{r org-save-pvals}
org_pvals <- list(org_rain_LD[1:2], 
                        select(org_echo_LD, "Identifier", "LD_echo"), 
                        org_rain_LL[1:2], 
                        select(org_echo_LL, "Identifier", "LL_echo")) %>% 
  reduce(full_join, by = "Identifier") # list all identifiers + p-values, and bring into one table

org_pvals # check table

write_xlsx(org_pvals, "organelle_rhythmicity_pvals.xlsx") # write to file to load into tool
```

Combining all *p*-values for nuclear and organellar proteomes into one table:

```{r all-pvals}
nuc_pvals <- read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM5_ESM.xlsx",
                        na = "ND") %>% mutate(across(!Identifier, as.numeric))  # pre-calculated eJTK/rain/echo LD and LL p-values
org_pvals <- select(org_proteome, "Identifier", "LD_ejtk" = "p_val_LD", "LL_ejtk" = "p_val_LL") # pre-calculated eJTK values for organellar proteome
my_org_pvals <- read_excel("organelle_rhythmicity_pvals.xlsx") # RAIN and ECHO p-values for organellar proteome, that I calculated

all_org_pvals <- left_join(org_pvals, my_org_pvals, by = "Identifier") %>% 
  relocate(LL_ejtk, .after = LD_echo) # combine and set correct column order
protein_pvals <- bind_rows(nuc_pvals, all_org_pvals) # combine into one table

protein_pvals # check table
tail(protein_pvals) # check organellar values are at end of table
```

# Rhythmic proteins

I used the calculated *p*-values to extract only the proteins that were identified as rhythmic in LL conditions (with a threshold of *p* \< 0.05) from the full dataset.

Filtering to rhythmic proteins:

```{r filter-to-rhythmic-proteins}
double_rhythmic_pvals <- filter(protein_pvals, 
                                LL_rain < 0.05 & LL_echo < 0.05) # find proteins rhythmic according to both RAIN and ECHO in LL
double_rhythmic_pvals # preview list of proteins + p-values

double_rhythmics_nuc <- filter(nuc_proteome, 
                               Identifier %in% double_rhythmic_pvals$Identifier) # get full information for rhythmic proteins from main table

double_rhythmics_org <- filter(org_proteome, 
                               Identifier %in% double_rhythmic_pvals$Identifier) %>% rename(GeneType = Gene, description = Name) # get full information (renaming columns so they bind properly)

double_rhythmics_nuc
double_rhythmics_org # preview outcome

double_rhythmics_full <- bind_rows(double_rhythmics_nuc, double_rhythmics_org) # bind to one table
double_rhythmics_full
```

Of the 6,599 nuclear-encoded proteins in the original dataset, 951 (14.4%) were identified as rhythmic by both RAIN and ECHO. Of the 75 organellar-encoded proteins, 21 (28%) were identified as rhythmic by both RAIN and ECHO.

## Rhythmic proteins with ion-related domains

Within these, I wanted to highlight any rhythmic proteins that may interact with the rhythmic ions in some way, as predicted by having run their amino acid sequences through InterPro.

Identifying rhythmically-abundant proteins with ion-binding protein domains:

```{r rhythmics-with-ion-domains}
filter_list <- c("Magnesium", "Mg2\\+", "Potassium", "K\\+") # slashes are needed so the + is processed properly

filtered_rhythmics <- tibble() # create table to add results into

for (term in filter_list) {
  matching <- filter(double_rhythmics_full, 
                     str_detect(protein_domains, regex(term, ignore_case = TRUE))) # get proteins that mention the search terms
  filtered_rhythmics <- rbind(filtered_rhythmics, matching) # add to new table
}

select(filtered_rhythmics, "Identifier", "description", "protein_domains") # view results
filtered_rhythmics
```

This identifies 9 proteins rhythmic in LL (according to both RAIN and ECHO), with domains labelled as having something to do with either magnesium or potassium.\
However, I wanted to see if there were any more, by examining proteins known to use these ions as co-factors. This was particularly pertinent because the organelle-derived proteome lacked domain information.

## Proteins with Mg as a co-factor

For this, I searched on UniProt for all proteins in *Ostreococcus tauri* OTTH0595 that use Mg2+ as a co-factor using its ChEBI number, and downloaded the result as a .tsv file. 146 protein entries were identified in this search.

Loading the .tsv file into R and examining it:

```{r load-mg-cofactor-table}
mg_cofactor_table <- read_tsv("uniprotkb_cc_cofactor_chebi_CHEBI_18420_2025_03_13.tsv", name_repair = function(x) gsub("\\s+", "_", x)) # load in table
mg_cofactor_table
```

To compare this list to the existing proteome data, the names need to all just be ostta numbers instead of a mixture of ostta numbers (from the ORCAE v2 genome) with an OT\_ prefix, OtC numbers (from the chloroplast genome isolated in 2007), BE221 drafts, and so on.\
Some entries also lack ostta numbers (instead having BE221DRAFT\_ s only), so that also needs resolving by searching for their amino acid sequences in the existing proteome data to get an ostta number.

Creating a list of all gene names and their corresponding amino acid sequences, using the nuclear and organellar proteome datasets from Kay *et al.*:

```{r lists-of-sequences-identifiers}
# get lists of gene names and corresponding amino acid sequences from other tables
nuc_seqs <- select(nuc_proteome, Identifier, Sequence = Amino_acid_sequence) %>% mutate(Sequence = str_remove_all(Sequence, "\\*"))
org_seqs <- select(org_proteome, Identifier, Sequence = Amino_acid_sequence) %>% mutate(Sequence = str_remove_all(Sequence, "\\*"))
# THESE HAVE TRAILING ASTERISKS FOR SOME REASON (because of coming from ORCAE?)

nuc_seqs # should have 6599 rows
org_seqs # should have 75 rows

proteome_seqs <- rbind(nuc_seqs, org_seqs) # combine into one big list for later
proteome_seqs
```

Extracting list of isolated names and sequences from the Mg2+ cofactor table:

```{r mg-co-identifiers-sequences}

mg_co_seqs <- select(mg_cofactor_table, Gene_Names, Sequence) %>% # get list of 146 sequences from cofactor table
  mutate(Identifier = str_extract(Gene_Names, "OtC.*|ostta.*")) # isolate to ostta or OtC numbers, if they're there

mg_co_seqs # should have 146 rows

count(mg_co_seqs, Sequence, sort = TRUE) # check every sequence only shows up once
count(mg_co_seqs, Identifier, sort = TRUE) # 4 sequences lack ostta/OtC numbers
```

This highlights that 4 of the sequences in the cofactor table do not have either an ostta\_ or OtC\_ formatted name, so these will need to be filled in by cross-referencing against the proteome datasets.

Combining the lists to fill in the gaps:

```{r mg-co-join-missing-identifiers}
mg_co_joined <- left_join(select(mg_co_seqs, !Gene_Names), proteome_seqs,
  by = "Sequence", suffix = c("_MgCo", "_Proteome")
) # join lists together

count(mg_co_joined, Identifier_MgCo, sort = TRUE) # 4 missing identifiers
count(mg_co_joined, Identifier_Proteome, sort = TRUE) # 9 identifiers in co-factor table but not kay proteome

mg_co_joined

mg_co_seqs <- unite(mg_co_joined, Identifier, !Sequence, na.rm = TRUE) %>%
  mutate(Identifier = str_remove(Identifier, "_.*")) # combine columns

mg_co_seqs # still at 146, so all the gaps were successfully filled by combining
```

Now that I have a cleaner list of identifiers, I can update the initial table:

```{r clean-mg-cofactor-table}
mg_cofactor_table <- mutate(mg_cofactor_table, Gene_Names = mg_co_seqs$Identifier) %>% rename(Identifier = Gene_Names) # swap old column out for new one

mg_cofactor_table
```

From here, I can now extract the full information for any proteins with Mg2+ as a co-factor that have also been identified as rhythmic in LL, using the ostta numbers.

Finding rhythmically-abundant proteins that use Mg2+ as a co-factor:

```{r mg-co-find-rhythmics}
mg_co_rhythmics <- tibble() # initialise blank tibble to add results to
double_rhythmics <- select(double_rhythmics_full, Identifier, Amino_acid_sequence, description, protein_domains) # extract relevant columns from full table

for (ostta in mg_co_seqs$Identifier) {
  # cat("Current identifier:",ostta,"\n\n") # test
  result <- filter(double_rhythmics, Identifier %in% ostta) # get row of rhythmics table where each identifier is
  mg_co_rhythmics <- rbind(mg_co_rhythmics, result) # add to the blank tibble
}

mg_co_rhythmics # NB: derived from proteome table
```

This identifies 17 proteins that are rhythmic in LL conditions (according to both RAIN and ECHO), and also bind Mg2+ as a co-factor.

7 of them have descriptions missing in the proteome table, so I ran the sequences against BLAST and took the best result to get one manually.

Manually filling in missing descriptions from BLAST results:

```{r mg-co-fill-descriptions}
mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta17g02305"] <- "DeoxyUTP pyrophosphatase"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta07g04440"] <- "CobB/CobQ glutamine amidotransferase"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta15g02070"] <- "Inositol monophosphatase, metal-binding site"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta09g03680"] <- "Uncharacterised protein family UPF0061"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta09g03000"] <- "5-formyltetrahydrofolate cyclo-ligase"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta06g01610"] <- "RIO2 kinase, winged helix, N-terminal"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta06g04170"] <- "P-loop containing nucleoside triphosphate hydrolase"
```

Comparing filled-in names to the ones originally on the co-factor table:

```{r mg-co-compare-names, eval=FALSE, include=FALSE}
full_join(
  (select(mg_co_rhythmics, Identifier, description)),
  (filter(mg_cofactor_table, Identifier %in% mg_co_rhythmics$Identifier) %>% select(Identifier, Protein_names)),
  by = "Identifier"
) %>% View() # compare filled-in names to initial ones from cofactor table
```

I wanted to view these results in an Excel file, so I wrote them to one:

```{r mg-co-write-to-file, eval=FALSE, include=FALSE}
#print(unlist(c(mg_co_rhythmics$Identifier, mg_co_rhythmics$Amino_acid_sequence)))

write_xlsx(filter(mg_cofactor_table, Identifier %in% mg_co_rhythmics$Identifier),
        "rhythmic full cofactor table.xlsx")
```

## Proteins with K as a co-factor

For this, I searched on UniProt for all proteins in *Ostreococcus tauri* OTTH0595 that use K+ as a co-factor using its ChEBI number, and downloaded the result as a .tsv file. 4 protein entries were identified in this search.

Loading in the resultant .tsv file to R:

```{r load-k-cofactor-table}
k_cofactor_table <- read_tsv("uniprotkb_cc_cofactor_chebi_CHEBI_29103_2025_03_13.tsv", name_repair = function(x) gsub("\\s+", "_", x))
k_cofactor_table
```

This shows 4 results. As with the Mg2+ table, to compare this list to the existing proteome data, the names need to all just be ostta numbers instead of having any OT\_ prefixes.\
Some entries also lack ostta numbers (instead having an OT only), so that also needs resolving by searching for their amino acid sequences in the existing proteome data to get an ostta number.

Checking and correcting the names:

```{r k-sequences-identifiers}
k_co_seqs <- select(k_cofactor_table, Gene_Names, Sequence) %>% # get list of  sequences from cofactor table
  mutate(Identifier = str_extract(Gene_Names, "OtC.*|ostta.*")) # isolate to ostta or OtC numbers, if they're there

k_co_seqs # 4

count(k_co_seqs, Sequence, sort = TRUE) # check every sequence only shows up once
count(k_co_seqs, Identifier, sort = TRUE) # 1 sequence lacks an ostta/OtC number
```

Using the list from the proteome datasets to fill in the gap:

```{r k-co-get-missing-identifiers}
k_co_joined <- left_join(select(k_co_seqs, !Gene_Names), proteome_seqs, by = "Sequence", suffix = c("_KCo", "_Proteome")) # join lists together

count(k_co_joined, Identifier_KCo, sort = TRUE) # 1 missing identifier
count(k_co_joined, Identifier_Proteome, sort = TRUE) # all identifiers in co-factor table are also in kay proteome

k_co_joined

k_co_seqs <- unite(k_co_joined, Identifier, !Sequence, na.rm = TRUE) %>%
  mutate(Identifier = str_remove(Identifier, "_.*")) # combine columns

k_co_seqs # still at 4, so the missing identifier was successfully filled by combining
```

Now that I have a cleaner list of identifiers, I can update the initial table:

```{r clean-k-cofactor-table}
k_cofactor_table <- mutate(k_cofactor_table, Gene_Names = k_co_seqs$Identifier) %>% rename(Identifier = Gene_Names) # swap old column out for new one
k_cofactor_table
```

From here, I can now extract the full information for any proteins with K+ as a co-factor that have also been identified as rhythmic in LL, using the ostta numbers.

```{r k-co-find-rhythmics}
k_co_rhythmics <- tibble() # initialise blank tibble to add results to
# already have double_rhythmics from before

for (ostta in k_co_seqs$Identifier) {
  # cat("Current identifier:",ostta,"\n\n") # test
  result <- filter(double_rhythmics, Identifier %in% ostta) # get row of table where each cofactor is
  k_co_rhythmics <- rbind(k_co_rhythmics, result) # add to a table
}

k_co_rhythmics
```

This identifies 1 protein that is rhythmic in LL conditions according to both RAIN and ECHO, and also binds K+ as a co-factor - in this case, it is a pyruvate kinase (ostta16g00480), which was already identified in the previous round of analysis because it also binds Mg2+ as a co-factor.

Due to this, I elected not to proceed with the k_co_rhythmics table, as it is contained within the mg_co_rhythmics table.

## Saving/loading results

The tool doesn't need to re-do all of this searching every time it is run, so I will save the results of this analysis to a file and load them in from that file in the tool.

Saving the mg_co_rhythmics table, containing the full proteome information for the rhythmic proteins, to a file:

```{r save-rhythmic-ion-binders, eval=FALSE, include=FALSE}
write_xlsx(mg_co_rhythmics, "mg_co_rhythmics.xlsx")

```

Loading the same table back in from the file, as will be done for the tool:

```{r load-rhythmic-ion-binders}

mg_co_rhythmics <- read_excel("mg_co_rhythmics.xlsx")
mg_co_rhythmics
```

Creating a table with the full information from the proteome dataset for each of the rhythmically-abundant proteins that use Mg as a co-factor, hence referred to as rhythmic ion-binders:

```{r rhythmic-ion-binders-full}
rhythmic_ion_binders_full <- filter(double_rhythmics_full, 
                                    Identifier %in% mg_co_rhythmics$Identifier) %>%
  select(Identifier, Amino_acid_sequence, description, Absolute_Phase_LL, Circadian_Phase_LL, protein_domains, everything()) %>%
  arrange(Absolute_Phase_LL) # get and reorder full proteome table for the 17

rhythmic_ion_binders_full
```

------------------------------------------------------------------------

# Ion exploration

The ion abundance data was originally presented in Gil Rodriguez *et al.*, 2024 (which is currently on bioRxiv). My project focuses on magnesium, calcium, and potassium because these are the ions good-quality data was obtained for. (phosphorus is also in the file, but is not being included in my tool)

Loading in the ion abundance data:

```{r load-ion-data}
ion_abundance <- read_excel("ions.xlsx", range = "A3:M41", col_names = c(
  "Time",
  "Mg_1", "Mg_2", "Mg_3", "Mg_4",
  "Ca_1", "Ca_2", "Ca_3", "Ca_4",
  "K_1", "K_2", "K_3", "K_4"
)) # columns aren't named in the actual raw file so that's done manually here
ion_abundance <- mutate(ion_abundance, Condition = case_when(Time <= 24 ~ "LD", Time >= 48 ~ "LL"), .after = Time) %>% drop_na() # add condition column

ion_abundance # preview file
```

In the tool, the values are loaded in from the spreadsheet once, and then subsections of this table are taken and formatted based on which ions the user chooses in the UI.

Early UI from the web tool:

```{r shiny-ion-input, eval=FALSE}
checkboxGroupInput(
  input = "ions", label = "Select ions:", selected = NULL,
  choices = c("Calcium" = "Ca", "Potassium" = "K", "Magnesium" = "Mg")
)

radioButtons("ion_abs_rel",
  label = "Plot abundance as:",
  choices = c("Absolute" = "abs", "Relative" = "rel")
)

checkboxInput(input = "ion_raw", label = "View raw values?")

radioButtons("ion_rain_echo",
  label = "Show LL values from:",
  choices = c("RAIN" = "rain", "ECHO" = "echo")
)
```

Server-side formatting from the tool:

```{r shiny-ion-data, eval=FALSE}
ion_data <- reactive({
  req(input$ions) # wait for an ion to be selected
  ion_data <- select(ion_abundance, "Time", contains(input$ions)) # create table with all necessary columns
  ion_data <- pivot_longer(ion_data, cols = !Time, names_to = "Ion", values_to = "Abundance") %>% drop_na()
  ion_data$Ion <- str_remove(ion_data$Ion, "\\_.*") # clean up ion names
  ion_data <- mutate(ion_data,
    Condition = case_when(ion_data$Time <= 24 ~ "LD", ion_data$Time >= 48 ~ "LL"),
    .after = Time
  ) # add condition column
  ion_data <- ion_data %>%
    group_by(Time, Condition, Ion) %>%
    summarise(across(), mean = mean(Abundance), sd = sd(Abundance)) %>%
    group_by(Ion) %>%
    mutate(rel_abun = mean / max(mean)) # add other/stats columns
})
```

## Abundance visualisation

The tool allows the change in abundance of each of the ions over time to be viewed on a graph.

### Absolute abundance

This works best when only one ion is being plotted.

```{r plot-ion-absolute, eval=FALSE}
ion_graph_abs <- ggplot(data = ion_data(), aes(x = Time, y = Abundance, group = Ion)) +
  ggtitle("Ion abundance") +
  geom_stripped_cols(width = 12, nudge_x = 6, odd = "#e5e5e5", even = "#ffffff", colour = "grey") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5), axis.title = element_text(size = 12)) +
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL) +
  scale_x_break(c(26, 48)) +
  ggborderline::geom_borderline(
    linewidth = 0.5, aes(
      y = mean, colour = Ion,
      group = interaction(Ion, Condition)
    ),
    bordercolour = "black"
  ) +
  geom_errorbar(aes(y = mean, ymin = mean - sd, ymax = mean + sd)) +
  geom_point(size = 2, aes(x = Time, y = Abundance, group = Ion, fill = Ion), shape = 21, colour = "black") +
  labs(x = "Time (h)", y = "Ion abundance (ug/L)")

ion_graph_abs
```

### Relative abundance

This is better for plotting multiple ions on the same graph.

```{r plot-ion-relative, eval=FALSE}
ggplot(data = ion_data(), aes(x = Time, y = rel_abun, group = Ion)) +
  ggtitle("Ion abundance") +
  geom_stripped_cols(width = 12, nudge_x = 6, odd = "#e5e5e5", even = "#ffffff", colour = "grey") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5), axis.title = element_text(size = 12)) +
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL) +
  scale_x_break(c(26, 48)) +
  ggborderline::geom_borderline(
    linewidth = 0.5, aes(colour = Ion, group = interaction(Ion, Condition)),
    bordercolour = "black"
  ) +
  geom_point(size = 2, aes(fill = Ion), shape = 21, colour = "black") +
  labs(x = "Time (h)", y = "Relative ion abundance")
```

## Calculation of rhythmicity

### RAIN

The RAIN method of detecting rhythmicity was implemented using the `rain()` function, from the package of the same name.

RAIN requires a time series to be given as a matrix, with time points as rows and sample series as columns (replicates are on subsequent rows). This is not the original layout of the ion table, so some pivoting is required first.

Formatting the ion abundance table for RAIN:

```{r ions-rain-table}
ions_rain_table <- pivot_longer(ion_abundance, cols = -c(Time, Condition), names_to = "Ion", values_to = "Abundance") %>%
  separate_wider_delim(cols = "Ion", delim = "_", names = c("Ion", "Replicate")) %>%
  pivot_wider(names_from = Ion, values_from = Abundance) %>%
  select(-Replicate) # get values in necessary format
ions_rain_table
```

Once the data is arranged in the correct format, it can then go into the `rain()` function. All parameters were kept the same as those applied to the proteome in [Kay *et al.* (2021)](https://doi.org/10.1038/s42003-021-02680-3), to better facilitate comparison of the results, except where changes were necessary to reflect differences in sampling (i.e. `deltat = 2` because the ion abundance samples were taken 2 hours apart, and `nr.series = 4` because there are 4 replicates for each ion).

Running RAIN on the ion abundance data:

```{r run-rain-for-ions, eval=FALSE}
# NB: this takes ages to run for some reason

ions_rain_LD <- filter(ions_rain_table, Condition == "LD") %>%
  select(-c(Time, Condition)) %>%
  as.matrix() %>%
  rain(
    period = 24, period.delta = 0, method = "independent", # only 24-hour periods
    deltat = 2, nr.series = 4, verbose = TRUE
  ) %>% rownames_to_column("Ion")  # matches paper for proteome

ions_rain_LL <- filter(ions_rain_table, Condition == "LL") %>%
  select(-c(Time, Condition)) %>%
  as.matrix() %>%
  rain(
    period = 24, period.delta = 4, method = "longitudinal", # 22-28 hour periods
    deltat = 2, nr.series = 4, verbose = TRUE
  ) %>% rownames_to_column("Ion") # matches paper for proteome

ions_rain_LD
ions_rain_LL
```

This has identified all three ions as rhythmic in both LD and LL, interestingly enough, though Ca is much less than the other two (which makes sense).\
Peak shape refers to the number of time points in the falling part of the oscillation - more sine-shaped oscillations will have more balanced peak shapes, but a sawtooth with a long rising and short falling shape would have a lower peak shape number.

```{r inverse-method-tests, eval = FALSE}
indep_LD <- ions_rain_LD # originals (independent LD)
longit_LL <- ions_rain_LL # original (longitudinal LL)

longit_LD <- filter(ions_rain_table, Condition == "LD") %>%
  select(-c(Time, Condition)) %>%
  as.matrix() %>%
  rain(
    period = 24, period.delta = 0, method = "longitudinal", # only 24-hour periods
    deltat = 2, nr.series = 4, verbose = TRUE
  ) %>% rownames_to_column("Ion") # try inverse method
longit_LD

indep_LL <- filter(ions_rain_table, Condition == "LL") %>%
  select(-c(Time, Condition)) %>%
  as.matrix() %>%
  rain(
    period = 24, period.delta = 4, method = "independent", # 22-28 hour periods
    deltat = 2, nr.series = 4, verbose = TRUE
  ) %>% rownames_to_column("Ion") # try inverse method
indep_LL

print("Independent method for both: ")
indep_LD
indep_LL

print("Longitudinal method for both: ")
longit_LD
longit_LL
```

### ECHO

The ECHO method was implemented using the `echo.find()` function, from the package of the same name.

ECHO requires sample series to be in rows, with replicates ordered by time point as columns. The original table is not in this format, so some initial pivoting is required first.

Formatting the ion abundance table for ECHO:

```{r ions-echo-table}
ions_echo_table <- pivot_longer(ion_abundance, cols = -c(Time, Condition), names_to = "Ion", values_to = "Abundance") %>%
  drop_na() %>%
  separate_wider_delim(cols = "Ion", delim = "_", names = c("Ion", "Replicate")) %>%
  select(-Condition) %>%
  pivot_wider(names_from = c("Time", "Replicate"), values_from = c("Abundance")) # get values in right format

ions_echo_table
```

Once the data is in the correct format for ECHO, the function can be run on the LD and LL data. All parameters were kept the same as those known to have been applied to the proteome in [Kay *et al.* (2021)](https://doi.org/10.1038/s42003-021-02680-3) to better facilitate comparison of the results, except where changes were necessary to reflect differences in sampling (i.e. `resol = 2` because the ion abundance samples were taken 2 hours apart, `num_reps = 4` because there are 4 replicates for each ion).

Running ECHO on the ion abundance data:

```{r run-echo-for-ions}
ions_echo_LD <- select(ions_echo_table, Ion, "0_1":"24_4") %>%
  echo_find(
    begin = 0, end = 24, resol = 2, num_reps = 4, low = 24, high = 24, run_all_per = FALSE,
    paired = FALSE, rem_unexpr = FALSE, is_normal = FALSE, is_de_linear_trend = FALSE,
    is_smooth = FALSE
  ) %>%
  rename(Ion = "Gene Name") # run echo for relevant time points

ions_echo_LL <- select(ions_echo_table, Ion, "48_1":"96_4") %>%
  echo_find(
    begin = 48, end = 96, resol = 2, num_reps = 4, low = 20, high = 28, run_all_per = FALSE,
    paired = FALSE, rem_unexpr = FALSE, is_normal = FALSE, is_de_linear_trend = TRUE,
    is_smooth = FALSE
  ) %>%
  rename(Ion = "Gene Name") # run echo for relevant time points

ions_echo_LD
ions_echo_LL

select(ions_echo_LD, "Ion", "Oscillation Type", "Period", "P-Value":"BY Adj P-Value") # view results
select(ions_echo_LL, "Ion", "Oscillation Type", "Period","P-Value":"BY Adj P-Value") # view results
```

This has identified K as most significantly rhythmic in LD conditions, followed by Ca (and determines that Mg is not significantly rhythmic in LD at the *p* \< 0.05 threshold). Mg and Ca are assigned a repressed oscillation type (where the amplitude decreases considerably over time), while K is labelled a harmonic oscillation (where amplitude remains mostly the same over time).\
Conversely, all three ions are once again identified as rhythmic in LL conditions (except Ca but only when the *p*-value is adjusted using the BY method), though much more significantly for Mg and K versus Ca. Mg and K are assigned a damped oscillation type, where the amplitude of the rhythm decreases with time, while Ca is assigned an overexpressed oscillation type, which is the opposite (amplitude increases with time, to the point ECHO no longer counts it as circadian). The period of Mg is longer than Ca or K.

ECHO fits the original time points to the assigned oscillation type's differential equation, so I want to see how this fit is different to the original samples.

Extracting the "original" and "fit" ion abundance data from ECHO:

```{r echo-fit-data}
ions_echo_LL_ori <- select(ions_echo_LL, "Ion", starts_with("Original")) %>% rename_with(~ str_remove(., "Original TP"), everything()) %>% # get relevant columns
  pivot_longer(cols = !"Ion", names_to = "Time", values_to = "Abundance")
# This has 4 rows per time point, so I need to get the mean
ions_echo_LL_ori$Time <- str_remove(ions_echo_LL_ori$Time, "\\..*")
ions_echo_LL_ori <- ions_echo_LL_ori %>%
  group_by(Ion, Time) %>%
  summarise(across(), mean = mean(Abundance)) %>%
  distinct(Ion, Time, mean) %>%
  pivot_wider(names_from = "Ion", values_from = "mean") %>%
  ungroup() # pivot to plot


ions_echo_LL_fit <- select(ions_echo_LL, "Ion", starts_with("Fitted")) %>%
  rename_with(~ str_remove(., "Fitted TP"), everything()) %>% # get relevant columns
  pivot_longer(cols = !"Ion", names_to = "Time", values_to = "Abundance") %>%
  pivot_wider(names_from = "Ion", values_from = "Abundance") # pivot to plot

ions_echo_LL_ori
ions_echo_LL_fit
```

Plotting the abundance values on a graph:

```{r plot-echo-fit-data}
ions_echo_LL_to_plot <- left_join(ions_echo_LL_ori, ions_echo_LL_fit,
  by = "Time",
  suffix = c("_Original", "_Fitted")
)
ions_echo_LL_to_plot

echo_plot_data <- ions_echo_LL_to_plot %>% mutate(Time = as.numeric(Time)) %>%
  pivot_longer(cols = !Time, names_to = "Ion", values_to = "Abundance") %>%
  separate_wider_delim(cols = Ion, delim = "_", names = c("Ion", "Status")) %>%
  group_by(Ion, Status) %>%
  mutate(zero_one = ((Abundance - min(Abundance)) /
    (max(Abundance) - min(Abundance)))) %>%
  ungroup()

echo_plot_data_ori <- filter(echo_plot_data, Status == "Original") 
echo_plot_data_fit <- filter(echo_plot_data, Status == "Fitted")

echo_plot <- ggplot(data = echo_plot_data, 
                    aes(x = Time, y = Abundance, group = interaction(Ion, Status), colour = interaction(Ion, Status))) +
  geom_line(linewidth = 0.8) +
  geom_point() +
  geom_point(colour = "black", shape = 21) +
  labs(y = "Processed abundance")

echo_plot

echo_plot_ori <- ggplot(data = echo_plot_data_ori, 
                    aes(x = Time, y = zero_one, group = Ion, colour = Ion)) +
  geom_rect(
        data = time_shading,
        aes(
          y = NULL, group = NULL, colour = NULL,
          xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, fill = colour
        ),
        show.legend = FALSE
      ) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # allow rest of graph to use different shading method
  
  geom_line(linewidth = 0.8) +
  geom_point() +
  geom_point(colour = "black", shape = 21) +
  scale_x_continuous(breaks = scales::breaks_width(12), limits = c(48,97)) +
  labs(x = "Time (h)", y = "Processed abundance")

echo_plot_ori

echo_plot_fit <- ggplot(data = echo_plot_data_fit, 
                    aes(x = Time, y = Abundance, group = Ion, colour = Ion)) +
  geom_rect(
        data = time_shading,
        aes(
          y = NULL, group = NULL, colour = NULL,
          xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, fill = colour
        ),
        show.legend = FALSE
      ) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # allow rest of graph to use different shading method
  
  geom_line(linewidth = 0.8) +
  geom_point() +
  geom_point(colour = "black", shape = 21) +
  scale_x_continuous(breaks = scales::breaks_width(12), limits = c(48,97)) +
  labs(x = "Time (h)", y = "Processed abundance")
echo_plot_fit
```

### Saving/loading results

For the Shiny tool, I have chosen to save these calculated rhythmicity values for the ions to their own Excel spreadsheet (similar to the one that exists for the proteome), as they do not need to be re-calculated every time the tool is launched.

Saving ion rhythmicity values to an Excel file:

```{r save-ion-rhythmicity}
ion_rhythmicity <- list(ions_rain_LD, ions_rain_LL, ions_echo_LD, ions_echo_LL) # get values as list
names(ion_rhythmicity) <- c("ions_rain_LD", "ions_rain_LL", "ions_echo_LD", "ions_echo_LL")
write_xlsx(ion_rhythmicity, "ion_rhythmicity.xlsx") # write each table of values to its own sheet
```

These are then loaded in from this spreadsheet when the tool is first launched, in a similar way to the protein datasets.

Loading ion rhythmicity values from the Excel file:

```{r load-ion-rhythmicity}
ion_rhythmicity <- "ion_rhythmicity.xlsx" # set file name in tool
ion_rhythmicity <- ion_rhythmicity %>%
  excel_sheets() %>% # get name of sheets from the file
  set_names() %>% # set names of each variable to name of sheet
  map(read_excel, path = ion_rhythmicity) %>% # create list of pre-calculated outputs
  list2env(.GlobalEnv) # allow each output to be accessed individually, like how they went into the raw excel file in the first place

ions_rain_LD
ions_rain_LL
ions_echo_LD
ions_echo_LL
```

------------------------------------------------------------------------

# Rhythmic ion-binders

I want to explore the 17 proteins identified as rhythmically-abundant and also using Mg2+ as a co-factor in more detail.

```{r}
rhythmic_ion_binders_full # from proteome
mg_co_rhythmics # from cofactor table

mg_co_rhythmics_full <- filter(mg_cofactor_table, Identifier %in% mg_co_rhythmics$Identifier)
mg_co_rhythmics_full

write_xlsx(mg_co_rhythmics_full, "mg_co_rhythmics_full.xlsx")
```

## Heatmaps

These are a good way of visualising how the abundance of each protein oscillates over time.

My initial attempts at creating heatmaps:

```{r phase-heatmaps-initial}
# should probably be in the format time/identifier/abundance to plot properly

phase_heatmap_data <- select(rhythmic_ion_binders_full, Identifier, Absolute_Phase_LL, Circadian_Phase_LL, "48":"121.5") %>% # get relevant columns for plotting
  pivot_longer(cols = -c(Identifier, Absolute_Phase_LL, Circadian_Phase_LL), names_to = "Time", names_transform = as.numeric, values_to = "Abundance", values_transform = as.numeric) %>% # pivot to plot properly
  group_by(Identifier) %>%
  mutate(
    rel_abun = Abundance / max(Abundance),
    norm_abun = (Abundance - mean(Abundance)) /
      (max(Abundance) - min(Abundance)),
    norm_z_score = (norm_abun - mean(norm_abun)) / sd(norm_abun),
    zeroone_abun = ((Abundance - min(Abundance)) /
      (max(Abundance) - min(Abundance)))
  ) %>%
  ungroup() %>%
  mutate(z_score = (Abundance - mean(Abundance)) / sd(Abundance)) # add extra columns

phase_heatmap_data # view outcome

phase_heatmap <- ggplot(data = phase_heatmap_data, aes(x = Time, y = fct_reorder(Identifier, Circadian_Phase_LL), fill = zeroone_abun)) +
  geom_tile() +
  #geom_smooth(aes(y = rel_abun, group = Identifier, colour = Identifier), span = 0.2, se = FALSE) +
  #  geom_vline(xintercept = c(48, 60, 72, 84, 96, 108, 120), alpha = 0.5) +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12)
  ) +
  labs(
    x = "Time (h)", y = "Identifier (by circadian phase)\n",
    fill = "Normalised\nabundance"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(12)) +
  # scale_fill_gradient(high = "yellow", low = "red")
  scale_colour_viridis_d(option = "turbo") +
  scale_fill_viridis(option = "D")
phase_heatmap

# base_phase_heatmap <- select(rhythmic_ion_binders_full, Identifier, "48":"121.5") %>%
#   column_to_rownames("Identifier") %>%
#   as.matrix()
# 
# heatmap(base_phase_heatmap) # try base R version
# 
# 
# phase_circular <- ggplot(data = phase_heatmap_data, 
#                          aes(x = Abundance, y = Time, fill = norm_abun)) +
#   geom_tile() +
#   coord_polar() +
#   scale_x_continuous(breaks = scales::breaks_width(1)) +
#   labs(title = "Title") +
#   scale_fill_gradient(high = "yellow", low = "red")
# 
#  phase_circular # this isn't right
```

This works, but since the abundance of each protein was only recorded every 3.5 hours, interpolating the data will create a "higher-resolution" heatmap. I chose to interpolate to every 0.5 hours in order to incorporate all of the original data points properly.

Creating and plotting an interpolated version of the protein abundance data:

```{r interpolated-phase-heatmaps}
interped_times <- seq(48, 121.5, 0.5) # create list of time points to interpolate for

interped_heatmap_data <- select(rhythmic_ion_binders_full, Identifier, Absolute_Phase_LL, Circadian_Phase_LL, "48":"121.5") %>% # get relevant columns
  add_column(!!!interped_times, .name_repair = "minimal") %>% # add times to interpolate into
  pivot_longer(cols = -c(Identifier, Absolute_Phase_LL, Circadian_Phase_LL), names_to = "Time", names_transform = as.numeric, values_to = "Abundance") %>% # condense all times to one column
  mutate(Abundance = case_when(Time == Abundance ~ NA, TRUE ~ Abundance)) %>% # clean up default values from add_column()
  arrange(Time) %>%
  distinct(Identifier, Time, .keep_all = TRUE) %>% # remove unnecessary rows
  group_by(Identifier) %>%
  mutate(Abundance = na.spline(Abundance, na.rm = FALSE), # interpolate (can also approx)
    zero_one = ((Abundance - min(Abundance)) /
      (max(Abundance) - min(Abundance))) # normalise to 0-1
  ) %>%
  ungroup()

interped_heatmap_data # view outcome

interped_heatmap <- ggplot(data = interped_heatmap_data, 
                           aes(x = Time, y = fct_reorder(Identifier, Circadian_Phase_LL),
                              fill = zero_one)) +
  geom_tile() +
  #  geom_vline(xintercept = c(48, 60, 72, 84, 96, 108, 120), alpha = 0.5) +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12)
  ) +
  labs(
    x = "Time (h)", y = "Identifier (by circadian phase)\n",
    fill = "Normalised\nabundance"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(12)) +
  scale_fill_viridis(option = "D")
# scale_fill_gradient(high = "yellow", low = "red") # construct heatmap

interped_heatmap # view resultant plot
```

Interpolating gives a clearer heatmap.

For circadian data, it can be advantageous to plot it circularly, but since the protein abundance data is over 3 days of LL, it needs to be condensed into a 24-hour window.

```{r circular-mg-heatmap}
# like AB's figure in multiomics
circ_heatmap_data <- select(interped_heatmap_data, 
                            "Identifier", "Time", "Abundance", "zero_one") %>%
  group_by(Identifier) %>%
  mutate(peak_time = Time[Abundance == max(Abundance)]) %>%
  ungroup()
  
circ_heatmap_data # view 

circ_heatmap <- ggplot(data = circ_heatmap_data, 
                       aes(x = Time, 
                           y = fct_reorder(Identifier, peak_time, .desc = TRUE),
                       fill = zero_one)) +
  geom_tile() +
    
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title = element_text(size = 12)
  ) +
  scale_x_continuous(breaks = scales::breaks_width(12)) +
  scale_fill_viridis(option = "D") +
  
  labs(x = "Time", y = "Identifier", fill = "Normalised\nabundance") +
  
  coord_radial(inner.radius = 0.6, expand = FALSE) # make circular

circ_heatmap
```

Creating a 24-hour circular heatmap:

```{r multiday-heatmap}
# My attempts to stack all three days on top of each other for the heatmap
# initial mutate line goes from 1 to 4 due to timepoints >= 120

multiday_data <- circ_heatmap_data %>%
  mutate(Day = (Time %/% 24) - 1, 
         ZT = Time %% 24, .after = Time) %>%
  filter(Day <= 3, .preserve = TRUE) %>% # remove timepoints after 120 for plotting
  unite(col = "ID_day", Identifier, Day, sep = "_", remove = FALSE) %>%
  
  group_by(ID_day) %>%
  mutate(peak_time = ZT[Abundance == max(Abundance)],
         zero_one = ((Abundance - min(Abundance)) /
      (max(Abundance) - min(Abundance)))
      ) %>% # recalculate 0-1 normalisation and peak time per day
  ungroup() 

multiday_data

multiday_heatmap <- ggplot(data = multiday_data, 
                       aes(x = ZT, 
                           y = fct_reorder2(ID_day, peak_time, Identifier, .desc = TRUE),
                       fill = zero_one)) +
  geom_tile() +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title = element_text(size = 12)
  ) +
  scale_x_continuous(breaks = scales::breaks_width(1)) +
  scale_fill_viridis(option = "D") +
  labs(x = "ZT", fill = "Normalised\nabundance")

multiday_heatmap

multiday_heatmap_circ <- ggplot(data = multiday_data, 
                       aes(x = ZT, 
                           y = fct_reorder2(ID_day, peak_time, Identifier, .desc = TRUE),
                       fill = zero_one)) +
  #geom_tile() +
  geom_rect(aes(xmin = ZT, xmax = ZT + 0.5, 
                ymin = stage(ID_day, after_scale = ymin-1),
                ymax = stage(ID_day, after_scale = ymax))
            ) +
  geom_vline(xintercept = c(0, 12), linewidth = 0.1, alpha = 0.5) + # check the axes aren't skewed
    
  scale_x_continuous(expand = c(0, 0), breaks = scales::breaks_width(1)) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_viridis(option = "D") +
    
  coord_radial(inner.radius = 0.6, expand = FALSE) + # make circular
    
  labs(x = "ZT", y = NULL, fill = "Normalised\nabundance")

multiday_heatmap_circ
```

Since fitting into 24 hours gives three different sets of data for each protein, which may not fully overlap well due to the periods of each protein being different, taking the mean of the 3 full days may give a clearer image.

```{r circular-heatmap-3-day-mean}

# let's just start back from the initial files again
circular_heatmap_data <- select(rhythmic_ion_binders_full, Identifier, "48":"121.5") %>% # get relevant columns
  add_column(!!!interped_times, .name_repair = "minimal") %>% # add times to interpolate into (note that this also fills the columns)
  pivot_longer(cols = -Identifier, names_to = "Time", names_transform = as.numeric, values_to = "Abundance") %>% # condense all times to one column
  
  mutate(Abundance = case_when(Time == Abundance ~ NA, TRUE ~ Abundance),
          # clean up default values from add_column() by replacing them with NAs
         ZT = Time %% 24) %>% # condense all times to 24-hour window
  arrange(Time) %>% # check NAs
  distinct(Identifier, Time, .keep_all = TRUE) %>% # remove unnecessary rows
  
  mutate(.by = Identifier,
         Abundance = na.spline(Abundance, na.rm = FALSE)) %>% # interpolate per ID
  
  filter(Time < 120) %>% # filter so each value only has 3 days
  
  mutate(.by = c(Identifier, ZT),
         perday_mean = mean(Abundance) # add mean of 3 days for each protein + time
         ) %>%
  mutate(.by = Identifier,
         peak_ZT = mean(ZT[perday_mean == max(perday_mean)]), # add peak time
         zero_one = (perday_mean - min(perday_mean)) /
                 (max(perday_mean) - min(perday_mean)) # add 0-1 normalisation 
         )

circular_heatmap_data # view outcome
distinct(circular_heatmap_data, Identifier, peak_ZT) %>% arrange(peak_ZT) # view peak time for each protein

mean_multiday_heatmap <- ggplot(data = circular_heatmap_data, 
                                aes(x = ZT, 
                                    y = fct_reorder(Identifier, peak_ZT, 
                                                     .desc = TRUE), 
                                    fill = zero_one)) +

  geom_rect(aes(xmin = ZT, xmax = ZT + 0.5, 
                ymin = stage(Identifier, after_scale = ymin-0.5),
                ymax = stage(Identifier, after_scale = ymax+0.5))
            ) + # add values as a heatmap
 # geom_vline(xintercept = c(0, 6, 12, 18), linewidth = 0.1, alpha = 0.5) + # check the axes aren't skewed
  theme(rect = element_rect(fill = "grey")) +
  scale_x_continuous(expand = c(0, 0), breaks = scales::breaks_width(1)) +
  scale_y_discrete(expand = c(0, 0)) +
  
  scale_fill_gradient2(low = "black", mid = "blue", high = "yellow", 
                       midpoint = 0.5) +
  #scale_fill_distiller(type = "div", palette = "RdBu") +
  #scale_fill_viridis(option = "D") +
    
  labs(x = "ZT", y = "Identifier", 
       fill = "Normalised\nabundance\n(n = 3)")

mean_multiday_heatmap

mean_heatmap_circ <- mean_multiday_heatmap + 
  coord_radial(inner.radius = 0.6, expand = FALSE) # make circular
  
mean_heatmap_circ

mean_multiday_traces <- ggplot(data = circular_heatmap_data,
                               aes(x = ZT,
                                   y = fct_reorder(Identifier, peak_ZT, 
                                                   .desc = TRUE),
                                   fill = zero_one)) +
  geom_point(shape = 22) +
  scale_fill_gradient2(low = "black", mid = "blue", high = "yellow", 
                       midpoint = 0.5)

mean_multiday_traces
```

```{r mean-multiday-peaks}
circular_heatmap_data

arrange(circular_heatmap_data, peak_ZT)

mean_multiday_peaks <- ggplot(data = circular_heatmap_data,
                              aes(x = fct_reorder(Identifier, peak_ZT), 
                                  y = peak_ZT)) +
  geom_point(aes(colour = fct_reorder(Identifier, peak_ZT))) +
  geom_text(aes(label = peak_ZT), nudge_y = 0.5, size = 3) +
  theme_grey() +
  theme(axis.text.x = element_text(angle = 80, hjust = 1)) +
  scale_y_continuous(breaks = c(0, 6, 12, 18, 24), 
                     minor_breaks = scales::breaks_width(2)) +
  labs(x = "Identifier", colour = "Identifier")

mean_multiday_peaks
```

# Comparing protein/ion phases

This chunk plots the phases of all proteins that are rhythmic in LL according to both RAIN and ECHO.

```{r plot-phase-graph}
ion_phases <- select(ions_rain_LL, Ion, phase) %>% filter(Ion != "Time")
protein_phases <- select(double_rhythmics_full, Identifier, phase = Circadian_Phase_LL)

ion_phases
protein_phases

protein_phases <- protein_phases %>% mutate(
  phase_vs_Mg = phase - 12,
  phase_vs_K = phase - 10
)

count(protein_phases, phase_vs_Mg, sort = TRUE)

protein_phases

phase_plot <- ggplot(data = protein_phases) +
  geom_freqpoly(aes(x = phase_vs_Mg), binwidth = 0.5) +
  xlim(-12, 12)

phase_plot # plot
```

Setting up a graph of traces vs. phases of the Mg-binding rhythmic proteins:

```{r trace-peak-setup}
ion_data <- ion_abundance # create table with all necessary columns
ion_data <- pivot_longer(ion_data, cols = -c(Time, Condition), names_to = "Ion", values_to = "Abundance") %>% drop_na()
ion_data$Ion <- str_remove(ion_data$Ion, "\\_.*") # clean up ion names
ion_data <- mutate(ion_data,
  Condition = case_when(ion_data$Time <= 24 ~ "LD", ion_data$Time >= 48 ~ "LL"),
  .after = Time
) # add condition column
ion_data <- ion_data %>%
  group_by(Time, Condition, Ion) %>%
  summarise(across(), mean = mean(Abundance), sd = sd(Abundance)) %>%
  group_by(Ion) %>%
  mutate(rel_abun = mean / max(mean)) # add other/stats columns

ion_data <- ion_data %>%
  filter(Ion != "Ca") # take out calcium because that's not really rhythmic
ion_data

rhythmic_abundance_iondays <- select(rhythmic_ion_binders_full, "Identifier", "48":"97") %>%
  pivot_longer(cols = !Identifier, names_to = "Time", values_to = "Abundance") # set up initial table of abundance values
rhythmic_abundance_iondays

peak_times <- rhythmic_abundance_iondays %>%
  group_by(Identifier) %>%
  mutate(Time = case_when(Abundance == max(Abundance) ~ as.numeric(Time))) %>% # keep only peak times
  ungroup() %>%
  distinct(Identifier, Time, .keep_all = TRUE) %>%
  drop_na() %>% # get peak time (and abundance value at that time) for all 16
  mutate(zero_one = (Abundance - min(Abundance)) /
                 (max(Abundance) - min(Abundance))) # normalise to 0-1

#peak_times %>% arrange(Time)
```

```{r trace-peaks-graph}

ion_data

trace_peaks_graph <- ggplot(data = ion_data,
  aes(x = Time, y = rel_abun, colour = Ion, group = Ion)) +
  
  geom_rect(data = time_shading,
                aes(y = NULL, group = NULL, colour = NULL,
                    xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, 
                    fill = colour), 
                show.legend = FALSE) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # let rest of graph use new shading 
  
  geom_line(linewidth = 0.8) +
  geom_point() +
  geom_point(shape = 21, colour = "black") + # plot ion traces
  
  geom_point(data = peak_times,
    aes(x = Time, y = 0.95, group = NULL, colour = NULL),
    shape = 4, size = 2, 
    position = position_jitter(width = 0, height = 0.05, seed = 1),
    show.legend = FALSE) + # plot peak times
    
  # geom_text(data = peak_times,
  #           aes(y = 0.95, group = NULL, colour = NULL, label = Identifier),
  #           size = 2.5,
  #           position = position_jitter(width = 0, height = 0.06, seed = 1), 
  #           show.legend = FALSE) + # add labels 
  
  geom_text_repel(data = peak_times,
            aes(y = 0.95, group = NULL, colour = NULL, label = Identifier),
            size = 2.5, 
            position = position_jitter(height = 0.05, seed = 1),
            show.legend = FALSE, 
            max.overlaps = Inf, min.segment.length = 0) +

  theme_bw() +
  
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL,
                     limits = c(48, 96)) # limit only to LL
  

trace_peaks_graph # show graph
```

```{r morn-eve-peaktrace-graph}
morneve_rhythmics <- filter(circular_heatmap_data, 
                            peak_ZT <= 3 | (peak_ZT >= 14 & peak_ZT < 21)) %>% 
  distinct(Identifier, peak_ZT) %>% arrange(peak_ZT) %>% 
  mutate(Time = peak_ZT + 48,
         ToD = case_when(peak_ZT <= 3 ~ "Morning",
                         peak_ZT >= 14 ~ "Evening"))

morneve_rhythmics

morneve_rhythmics_vs <- ggplot() +
  geom_rect(data = time_shading,
                aes(y = NULL, group = NULL,
                    xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, 
                    fill = colour), 
                show.legend = FALSE) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # let rest of graph use new shading
  
  geom_line(data = ion_data,
  aes(x = Time, y = rel_abun, colour = Ion, group = Ion), linewidth = 0.8) +
  geom_point(data = ion_data,
  aes(x = Time, y = rel_abun, colour = Ion, group = Ion), shape = 4, size = 2) +
  # geom_point(data = ion_data, 
  # aes(x = Time, y = rel_abun), colour = "black", shape = 21) + 
  
  #geom_point(data = morneve_rhythmics, aes(x = Time, y = 1, colour = ToD)) +
  new_scale_colour() +
  
  geom_point(data = morneve_rhythmics,
    aes(x = Time, y = 1, colour = ToD),
    size = 2,
    position = position_jitter(width = 0.01, height = 0.05, seed = 9)
    ) +
  scale_colour_manual(values = c("Morning" = "gold2", "Evening" = "navy") ) +
  geom_point(data = morneve_rhythmics,
    aes(x = Time, y = 1), colour = "black", shape = 21,
    size = 2,
    position = position_jitter(width = 0.01, height = 0.05, seed = 9)
    ) +
  
  geom_text_repel(data = morneve_rhythmics,
            aes(x = Time, y = 1, group = ToD, label = Identifier),
            size = 3,
            position = position_jitter(width = 0.01, height = 0.05, seed = 9),
            show.legend = FALSE,
            max.overlaps = Inf, min.segment.length = 0) +
  
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL,
                     limits = c(45, 72)) + # limit only to LL
  guides(colour = "legend", group = "legend") +
  labs(y = "Relative abundance")

morneve_rhythmics_vs
  
```

===

```{r end}
print("End chunk")
```
