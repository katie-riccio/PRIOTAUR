---
title: "Plant Science Research Project Notebook"
author: "Katie Riccio"
runtime: shiny
output: 
  html_notebook: 
    toc: true
---

This is my notebook for my honours research project.

# My project code

```{r libraries}
library(bslib)
library(echo.find)
library(ggplot2)
library(ggbreak)
library(ggnewscale) # for setting colour palette
library(shiny)
library(shinycssloaders)
library(plotly)
library(rain)
library(readxl)
library(tidyverse)
library(viridis)
library(writexl)
library(zoo) # for interpolation
```

# 

# Setup

```{r time-shading}
time_shading <- tibble(Time = seq(0, 122, 1)) %>%
  mutate(
    Condition = case_when(Time <= 24 ~ "LD", Time >= 48 ~ "LL"),
    ToD = case_when(
      ((Time %/% 12) %% 2) == 1 & Condition == "LD" ~ "Night",
      ((Time %/% 12) %% 2) == 1 & Condition == "LL" ~ "Subjective night",
      ((Time %/% 12) %% 2) == 0 ~ "Day"
    ),
    colour = case_when(
      ToD == "Day" ~ "#ffffff",
      ToD == "Night" ~ "#a5a5a5",
      ToD == "Subjective night" ~ "#e5e5e5"
    )
  ) %>% drop_na() # set up graph background 
time_shading

time_plot <- tibble(Time = seq(0,122,1),
                    Value = Time%%10) # create dummy table to plot

time_graph <- ggplot(data = time_plot, aes(x = Time, y = Value)) +
  geom_rect(data = time_shading,
                aes(y = NULL, group = NULL,
                    xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, 
                    fill = colour), 
                show.legend = FALSE) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # let rest of graph use new shading 
  
  geom_point(alpha = 0.5) # plot dummy table

time_graph # test that it works
```

------------------------------------------------------------------------

# Protein exploration

The deep-coverage proteome data was initially published in [Kay *et al.* (2021)](https://doi.org/10.1038/s42003-021-02680-3), and my tool makes use of the original dataset plus a smaller table of the calculated *p*-values for rhythmicity by eJTK, RAIN, and ECHO under LD and LL conditions.

```{r load-protein-data}
nuc_proteome <- read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", sheet = 2, na = "ND", .name_repair = function(x) gsub("\\s+", "_", x)) # nuclear-encoded proteome data

org_proteome <- read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM4_ESM.xlsx", sheet = 3, na = "ND", .name_repair = function(x) gsub("\\s+", "_", x)) # organellar-encoded proteome data

protein_rhythm_pvalues <- read_excel("Kay et al Comms Bio 2021/42003_2021_2680_MOESM5_ESM.xlsx", na = "ND") %>% mutate(across(!Identifier, as.numeric)) # pre-calculated eJTK/rain/echo LD and LL p-values (names don't need fixing here)

nuc_proteome # check nuclear proteome
org_proteome # check organellar proteome
protein_rhythm_pvalues # check rhythmicity values
```

Once these were loaded in, I used the pre-calculated *p*-values to extract only the proteins that were identified as rhythmic in LL conditions (with a threshold of *p* \< 0.05) from the full dataset.

```{r filter-to-rhythmic-proteins}
double_rhythmic_pvals <- filter(protein_rhythm_pvalues, 
                                LL_rain < 0.05 & LL_echo < 0.05) # find proteins rhythmic according to both RAIN and ECHO in LL
double_rhythmic_pvals # preview list of proteins + p-values

double_rhythmics_full <- filter(nuc_proteome, Identifier %in% double_rhythmic_pvals$Identifier) # get full information for rhythmic proteins from main table

double_rhythmics_full # preview outcome
```

Of the 6,599 proteins in the original dataset, 951 (14.4%) were identified as rhythmic by both RAIN and ECHO.

## Rhythmic proteins with ion-related domains

Within these, I wanted to highlight any rhythmic proteins that may interact with the rhythmic ions in some way, as predicted by having run their amino acid sequences through InterPro.

```{r rhythmics-with-ion-domains}
filter_list <- c("Magnesium", "Mg2\\+", "Potassium", "K\\+") # slashes are needed so the + is processed properly

filtered_rhythmics <- tibble() # create table to add results into

for (term in filter_list) {
  matching <- filter(double_rhythmics_full, 
                     str_detect(protein_domains, regex(term, ignore_case = TRUE))) # get proteins that mention the search terms
  filtered_rhythmics <- rbind(filtered_rhythmics, matching) # add to new table
}

select(filtered_rhythmics, "Identifier", "description", "protein_domains") # view results
filtered_rhythmics
```

This identifies 9 proteins rhythmic in LL (according to both RAIN and ECHO), with domains labelled as having something to do with either magnesium or potassium.\
However, I wanted to see if there were any more, by examining proteins known to use these ions as co-factors.

## Proteins with Mg as a co-factor

For this, I searched on UniProt for all proteins in *Ostreococcus tauri* OTTH0595 that use Mg2+ as a co-factor using its ChEBI number, and downloaded the result as a .tsv file. 146 protein entries were identified in this search.

```{r load-mg-cofactor-table}
mg_cofactor_table <- read_tsv("uniprotkb_cc_cofactor_chebi_CHEBI_18420_2025_03_13.tsv", name_repair = function(x) gsub("\\s+", "_", x)) # load in table
mg_cofactor_table
```

To compare this list to the existing proteome data, the names need to all just be ostta numbers instead of a mixture of ostta numbers (from the ORCAE v2 genome) with an OT\_ prefix, OtC numbers (I assume from the chloroplast genome isolated in 2007), BE221 drafts, and so on.\
Some entries also lack ostta numbers (instead having BE221DRAFT\_ s only), so that also needs resolving by searching for their amino acid sequences in the existing proteome data to get an ostta number.

```{r lists-of-sequences-identifiers}
# get lists of gene names and corresponding amino acid sequences from other tables
nuc_seqs <- select(nuc_proteome, Identifier, Sequence = Amino_acid_sequence) %>% mutate(Sequence = str_remove_all(Sequence, "\\*"))
org_seqs <- select(org_proteome, Identifier, Sequence = Amino_acid_sequence) %>% mutate(Sequence = str_remove_all(Sequence, "\\*"))
# THESE HAVE TRAILING ASTERISKS FOR SOME REASON

nuc_seqs # should have 6599 rows
org_seqs # should have 75 rows

proteome_seqs <- rbind(nuc_seqs, org_seqs) # combine into one big list for later

mg_co_seqs <- select(mg_cofactor_table, Gene_Names, Sequence) %>% # get list of 146 sequences from cofactor table
  mutate(Identifier = str_extract(Gene_Names, "OtC.*|ostta.*")) # isolate to ostta or OtC numbers, if they're there

mg_co_seqs # should have 146 rows

count(mg_co_seqs, Sequence, sort = TRUE) # check every sequence only shows up once
count(mg_co_seqs, Identifier, sort = TRUE) # 4 sequences lack ostta/OtC numbers
```

```{r mg-co-join-missing-identifiers}
mg_co_joined <- left_join(select(mg_co_seqs, !Gene_Names), proteome_seqs,
  by = "Sequence", suffix = c("_MgCo", "_Proteome")
) # join lists together

count(mg_co_joined, Identifier_MgCo, sort = TRUE) # 4 missing identifiers
count(mg_co_joined, Identifier_Proteome, sort = TRUE) # 9 identifiers in co-factor table but not kay proteome

mg_co_joined

mg_co_seqs <- unite(mg_co_joined, Identifier, !Sequence, na.rm = TRUE) %>%
  mutate(Identifier = str_remove(Identifier, "_.*")) # combine columns

mg_co_seqs # still at 146, so all the gaps were successfully filled by combining
```

Now that I have a cleaner list, I can update the initial table.

```{r clean-mg-cofactor-table}
mg_cofactor_table <- mutate(mg_cofactor_table, Gene_Names = mg_co_seqs$Identifier) %>% rename(Identifier = Gene_Names) # swap old column out for new one

mg_cofactor_table
```

From here, I can now extract the full information for any proteins with Mg2+ as a co-factor that have also been identified as rhythmic in LL, using the ostta numbers.

```{r mg-co-find-rhythmics}
mg_co_rhythmics <- tibble() # initialise blank tibble to add results to
double_rhythmics <- select(double_rhythmics_full, Identifier, Amino_acid_sequence, description, Absolute_Phase_LL, Circadian_Phase_LL, protein_domains) # get relevant columns of full table

for (ostta in mg_co_seqs$Identifier) {
  # cat("Current identifier:",ostta,"\n\n") # test
  result <- filter(double_rhythmics, Identifier %in% ostta) # get row of rhythmics table where each identifier is
  mg_co_rhythmics <- rbind(mg_co_rhythmics, result) # add to a new table
}

mg_co_rhythmics # NB: derived from proteome table
```

This identifies 16 proteins that are rhythmic in LL conditions (according to both RAIN and ECHO), and also bind Mg2+ as a co-factor.

7 of them have descriptions missing, so I ran the sequences against BLAST and took the best result to get one manually.

```{r mg-co-fill-descriptions}
mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta17g02305"] <- "DeoxyUTP pyrophosphatase"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta07g04440"] <- "CobB/CobQ glutamine amidotransferase"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta15g02070"] <- "Inositol monophosphatase, metal-binding site"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta09g03680"] <- "Uncharacterised protein family UPF0061"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta09g03000"] <- "5-formyltetrahydrofolate cyclo-ligase"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta06g01610"] <- "RIO2 kinase, winged helix, N-terminal"

mg_co_rhythmics$description[mg_co_rhythmics$Identifier == "ostta06g04170"] <- "P-loop containing nucleoside triphosphate hydrolase"
```

```{r mg-co-compare-names, eval=FALSE, include=FALSE}
full_join(
  (select(mg_co_rhythmics, Identifier, description)),
  (filter(mg_cofactor_table, Identifier %in% mg_co_rhythmics$Identifier) %>% select(Identifier, Protein_names)),
  by = "Identifier"
) %>% View() # compare filled-in names to initial ones
```

```{r mg-co-blast-arabidopsis, eval=FALSE, include=FALSE}
print(unlist(c(mg_co_rhythmics$Identifier, mg_co_rhythmics$Amino_acid_sequence)))
```

## Presenting as graphs

```{r rhythmic-ion-binders}
rhythmic_ion_binders_full <- filter(double_rhythmics_full, Identifier %in% mg_co_rhythmics$Identifier) %>%
  select(Identifier, Amino_acid_sequence, description, Absolute_Phase_LL, Circadian_Phase_LL, protein_domains, everything()) %>%
  arrange(Absolute_Phase_LL) # get and reorder full table for the 16

rhythmic_ion_binders_full
```

```{r rhythmic-binder-traces}

```

```{r phase-heatmaps-initial}
# should probably be in the format time/identifier/abundance to plot properly

phase_heatmap_data <- select(rhythmic_ion_binders_full, Identifier, Absolute_Phase_LL, Circadian_Phase_LL, "48":"121.5") %>% # get relevant columns for plotting
  pivot_longer(cols = -c(Identifier, Absolute_Phase_LL, Circadian_Phase_LL), names_to = "Time", names_transform = as.numeric, values_to = "Abundance", values_transform = as.numeric) %>% # pivot to plot properly
  group_by(Identifier) %>%
  mutate(
    rel_abun = Abundance / max(Abundance),
    norm_abun = (Abundance - mean(Abundance)) /
      (max(Abundance) - min(Abundance)),
    norm_z_score = (norm_abun - mean(norm_abun)) / sd(norm_abun),
    zeroone_abun = ((Abundance - min(Abundance)) /
      (max(Abundance) - min(Abundance)))
  ) %>%
  ungroup() %>%
  mutate(z_score = (Abundance - mean(Abundance)) / sd(Abundance)) # add extra columns

phase_heatmap_data # view outcome

phase_heatmap <- ggplot(data = phase_heatmap_data, aes(x = Time, y = fct_reorder(Identifier, Circadian_Phase_LL), fill = zeroone_abun)) +
  geom_tile() +
  #geom_smooth(aes(y = rel_abun, group = Identifier, colour = Identifier), span = 0.2, se = FALSE) +
  #  geom_vline(xintercept = c(48, 60, 72, 84, 96, 108, 120), alpha = 0.5) +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12)
  ) +
  labs(
    x = "Time (h)", y = "Identifier (by circadian phase)\n",
    fill = "Normalised\nabundance"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(12)) +
  # scale_fill_gradient(high = "yellow", low = "red")
  scale_colour_viridis_d(option = "turbo") +
  scale_fill_viridis(option = "D")
phase_heatmap

# base_phase_heatmap <- select(rhythmic_ion_binders_full, Identifier, "48":"121.5") %>%
#   column_to_rownames("Identifier") %>%
#   as.matrix()
# 
# heatmap(base_phase_heatmap) # try base R version
# 
# 
# phase_circular <- ggplot(data = phase_heatmap_data, 
#                          aes(x = Abundance, y = Time, fill = norm_abun)) +
#   geom_tile() +
#   coord_polar() +
#   scale_x_continuous(breaks = scales::breaks_width(1)) +
#   labs(title = "Title") +
#   scale_fill_gradient(high = "yellow", low = "red")
# 
#  phase_circular # this isn't right
```

```{r interpolated-phase-heatmaps}
interped_times <- seq(48, 121.5, 0.5) # create list of time points to interpolate for

interped_heatmap_data <- select(rhythmic_ion_binders_full, Identifier, Absolute_Phase_LL, Circadian_Phase_LL, "48":"121.5") %>% # get relevant columns
  add_column(!!!interped_times, .name_repair = "minimal") %>% # add times to interpolate into
  pivot_longer(cols = -c(Identifier, Absolute_Phase_LL, Circadian_Phase_LL), names_to = "Time", names_transform = as.numeric, values_to = "Abundance") %>% # condense all times to one column
  mutate(Abundance = case_when(Time == Abundance ~ NA, TRUE ~ Abundance)) %>% # clean up default values from add_column()
  arrange(Time) %>%
  distinct(Identifier, Time, .keep_all = TRUE) %>% # remove unnecessary rows
  group_by(Identifier) %>%
  mutate(Abundance = na.spline(Abundance, na.rm = FALSE), # interpolate (can also approx)
    zero_one = ((Abundance - min(Abundance)) /
      (max(Abundance) - min(Abundance))) # normalise to 0-1
  ) %>%
  ungroup()

interped_heatmap_data # view outcome

interped_heatmap <- ggplot(data = interped_heatmap_data, 
                           aes(x = Time, y = fct_reorder(Identifier, Circadian_Phase_LL),
                              fill = zero_one)) +
  geom_tile() +
  #  geom_vline(xintercept = c(48, 60, 72, 84, 96, 108, 120), alpha = 0.5) +
  theme_bw() +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title = element_text(size = 12)
  ) +
  labs(
    x = "Time (h)", y = "Identifier (by circadian phase)\n",
    fill = "Normalised\nabundance"
  ) +
  scale_x_continuous(breaks = scales::breaks_width(12)) +
  scale_fill_viridis(option = "D")
# scale_fill_gradient(high = "yellow", low = "red") # construct heatmap

interped_heatmap # view resultant plot

```

```         
```

## Proteins with K as a co-factor

For this, I searched on UniProt for all proteins in *Ostreococcus tauri* OTTH0595 that use K+ as a co-factor using its ChEBI number, and downloaded the result as a .tsv file. 4 protein entries were identified in this search.

```{r load-k-cofactor-table}
k_cofactor_table <- read_tsv("uniprotkb_cc_cofactor_chebi_CHEBI_29103_2025_03_13.tsv", name_repair = function(x) gsub("\\s+", "_", x))
k_cofactor_table
```

As with the Mg2+, to compare this list to the existing proteome data, the names need to all just be ostta numbers instead of a mixture of ostta numbers (from the ORCAE v2 genome) with an OT\_ prefix, OtC numbers (I assume from the chloroplast genome isolated in 2007), BE221 drafts, and so on.\
Some entries also lack ostta numbers (instead having BE221DRAFT\_ s only), so that also needs resolving by searching for their amino acid sequences in the existing proteome data to get an ostta number.

```{r k-sequences-identifiers, }
k_co_seqs <- select(k_cofactor_table, Gene_Names, Sequence) %>% # get list of  sequences from cofactor table
  mutate(Identifier = str_extract(Gene_Names, "OtC.*|ostta.*")) # isolate to ostta or OtC numbers, if they're there

k_co_seqs # 4

count(k_co_seqs, Sequence, sort = TRUE) # check every sequence only shows up once
count(k_co_seqs, Identifier, sort = TRUE) # 1 sequence lacks an ostta/OtC number
```

```{r k-co-get-missing-identifiers}
k_co_joined <- left_join(select(k_co_seqs, !Gene_Names), proteome_seqs, by = "Sequence", suffix = c("_KCo", "_Proteome")) # join lists together

count(k_co_joined, Identifier_KCo, sort = TRUE) # 1 missing identifier
count(k_co_joined, Identifier_Proteome, sort = TRUE) # all identifiers in co-factor table are also in kay proteome

k_co_joined

k_co_seqs <- unite(k_co_joined, Identifier, !Sequence, na.rm = TRUE) %>%
  mutate(Identifier = str_remove(Identifier, "_.*")) # combine columns

k_co_seqs # still at 4, so the missing identifier was successfully filled by combining
```

Now that I have a cleaner list, I can update the initial table.

```{r clean-k-cofactor-table}
k_cofactor_table <- mutate(k_cofactor_table, Gene_Names = k_co_seqs$Identifier) %>% rename(Identifier = Gene_Names) # swap old column out for new one
k_cofactor_table
```

From here, I can now extract the full information for any proteins with K+ as a co-factor that have also been identified as rhythmic in LL, using the ostta numbers.

```{r k-co-find-rhythmics}
k_co_rhythmics <- tibble() # initialise blank tibble to add results to
# already have double_rhythmics from before

for (ostta in k_co_seqs$Identifier) {
  # cat("Current identifier:",ostta,"\n\n") # test
  result <- filter(double_rhythmics, Identifier %in% ostta) # get row of table where each cofactor is
  k_co_rhythmics <- rbind(k_co_rhythmics, result) # add to a table
}

k_co_rhythmics
```

This identifies 1 protein that is rhythmic in LL conditions according to both RAIN and ECHO, and also binds K+ as a co-factor - in this case, it is a pyruvate kinase (ostta16g0040) which was already identified in the previous round of analysis because it also binds Mg2+ as a co-factor.

## Saving/loading results

The tool doesn't need to re-do all of this searching every time it is run, so I will save the results to a file and load them in from that file in the tool.

```{r save-rhythmic-ion-binders, eval=FALSE, include=FALSE}
write_xlsx(mg_co_rhythmics, "mg_co_rhythmics.xlsx")
mg_co_rhythmics <- read_excel("mg_co_rhythmics.xlsx")
mg_co_rhythmics
```

```{r load-rhythmic-ion-binding}
rhythmic_ion_binders <- read_excel("rhythmic_ion-binders.xlsx", range = "A1:G17")
rhythmic_ion_binders # this is the same as the mg_co_rhythmics table
```

# 

------------------------------------------------------------------------

# Ion exploration

The ion abundance data is unpublished. My project focuses on magnesium, calcium, and potassium because these are the ions good-quality data was obtained for. (phosphorus is also in the file, but is not being included in my tool)

```{r load-ion-data}
ion_abundance <- read_excel("ions.xlsx", range = "A3:M41", col_names = c(
  "Time",
  "Mg_1", "Mg_2", "Mg_3", "Mg_4",
  "Ca_1", "Ca_2", "Ca_3", "Ca_4",
  "K_1", "K_2", "K_3", "K_4"
)) # columns aren't named in the actual raw file so that's done manually here
ion_abundance <- mutate(ion_abundance, Condition = case_when(Time <= 24 ~ "LD", Time >= 48 ~ "LL"), .after = Time) %>% drop_na() # add condition column

ion_abundance # preview file
```

In the tool, the values are loaded in from the spreadsheet once, and then subsections of this table are taken and formatted based on which ions the user chooses in the UI.

```{r shiny-ion-input, eval=FALSE, include=FALSE}
checkboxGroupInput(
  input = "ions", label = "Select ions:", selected = NULL,
  choices = c("Calcium" = "Ca", "Potassium" = "K", "Magnesium" = "Mg")
)

radioButtons("ion_abs_rel",
  label = "Plot abundance as:",
  choices = c("Absolute" = "abs", "Relative" = "rel")
)

checkboxInput(input = "ion_raw", label = "View raw values?")

radioButtons("ion_rain_echo",
  label = "Show LL values from:",
  choices = c("RAIN" = "rain", "ECHO" = "echo")
)
```

```{r shiny-ion-data, eval=FALSE, include=FALSE}
ion_data <- reactive({
  req(input$ions) # wait for an ion to be selected
  ion_data <- select(ion_abundance, "Time", contains(input$ions)) # create table with all necessary columns
  ion_data <- pivot_longer(ion_data, cols = !Time, names_to = "Ion", values_to = "Abundance") %>% drop_na()
  ion_data$Ion <- str_remove(ion_data$Ion, "\\_.*") # clean up ion names
  ion_data <- mutate(ion_data,
    Condition = case_when(ion_data$Time <= 24 ~ "LD", ion_data$Time >= 48 ~ "LL"),
    .after = Time
  ) # add condition column
  ion_data <- ion_data %>%
    group_by(Time, Condition, Ion) %>%
    summarise(across(), mean = mean(Abundance), sd = sd(Abundance)) %>%
    group_by(Ion) %>%
    mutate(rel_abun = mean / max(mean)) # add other/stats columns
})
```

## Abundance visualisation

The tool allows the change in abundance of each of the ions over time to be viewed on a graph.

### Absolute abundance

This works best when only one ion is being plotted.

```{r plot-ion-absolute, eval=FALSE, include=FALSE}
ion_graph_abs <- ggplot(data = ion_data(), aes(x = Time, y = Abundance, group = Ion)) +
  ggtitle("Ion abundance") +
  geom_stripped_cols(width = 12, nudge_x = 6, odd = "#e5e5e5", even = "#ffffff", colour = "grey") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5), axis.title = element_text(size = 12)) +
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL) +
  scale_x_break(c(26, 48)) +
  ggborderline::geom_borderline(
    linewidth = 0.5, aes(
      y = mean, colour = Ion,
      group = interaction(Ion, Condition)
    ),
    bordercolour = "black"
  ) +
  geom_errorbar(aes(y = mean, ymin = mean - sd, ymax = mean + sd)) +
  geom_point(size = 2, aes(x = Time, y = Abundance, group = Ion, fill = Ion), shape = 21, colour = "black") +
  labs(x = "Time (h)", y = "Ion abundance (ug/L)")

ion_graph_abs
```

### Relative abundance

This is better for plotting multiple ions on the same graph.

```{r plot-ion-relative, eval=FALSE, include=FALSE}
ggplot(data = ion_data(), aes(x = Time, y = rel_abun, group = Ion)) +
  ggtitle("Ion abundance") +
  geom_stripped_cols(width = 12, nudge_x = 6, odd = "#e5e5e5", even = "#ffffff", colour = "grey") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5), axis.title = element_text(size = 12)) +
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL) +
  scale_x_break(c(26, 48)) +
  ggborderline::geom_borderline(
    linewidth = 0.5, aes(colour = Ion, group = interaction(Ion, Condition)),
    bordercolour = "black"
  ) +
  geom_point(size = 2, aes(fill = Ion), shape = 21, colour = "black") +
  labs(x = "Time (h)", y = "Relative ion abundance")
```

## Calculation of rhythmicity

### RAIN

The RAIN method of detecting rhythmicity was implemented using the `rain()` function, from the package of the same name.

RAIN requires a time series to be given as a matrix, with time points as rows and sample series as columns (replicates are on subsequent rows). This is not the original layout of the ion table, so some pivoting is required first.

```{r ions-rain-table}
ions_rain_table <- pivot_longer(ion_abundance, cols = -c(Time, Condition), names_to = "Ion", values_to = "Abundance") %>%
  separate_wider_delim(cols = "Ion", delim = "_", names = c("Ion", "Replicate")) %>%
  pivot_wider(names_from = Ion, values_from = Abundance) %>%
  select(-Replicate) # get values in necessary format
ions_rain_table
```

Once the data is arranged in the correct format, it can then go into the `rain()` function. All parameters were kept the same as those applied to the proteome in [Kay *et al.* (2021)](https://doi.org/10.1038/s42003-021-02680-3), to better facilitate comparison of the results, except where changes were necessary to reflect differences in sampling (i.e. `deltat = 2` because the ion abundance samples were taken 2 hours apart, and `nr.series = 4` because there are 4 replicates for each ion).

```{r run-rain-for-ions, eval=FALSE, include=FALSE}
# NB: this takes ages to run for some reason

ions_rain_LD <- filter(ions_rain_table, Condition == "LD") %>%
  select(-c(Time, Condition)) %>%
  as.matrix() %>%
  rain(
    period = 24, period.delta = 0, method = "independent", # only 24-hour periods
    deltat = 2, nr.series = 4, verbose = TRUE
  ) %>% rownames_to_column("Ion")  # matches paper for proteome

ions_rain_LL <- filter(ions_rain_table, Condition == "LL") %>%
  select(-c(Time, Condition)) %>%
  as.matrix() %>%
  rain(
    period = 24, period.delta = 4, method = "longitudinal", # 22-28 hour periods
    deltat = 2, nr.series = 4, verbose = TRUE
  ) %>% rownames_to_column("Ion") # matches paper for proteome

ions_rain_LD
ions_rain_LL
```

This has identified all three ions as rhythmic in both LD and LL, interestingly enough, though Ca is much less than the other two (which makes sense).\
Peak shape refers to the number of time points in the falling part of the oscillation - more sine-shaped oscillations will have more balanced peak shapes, but a sawtooth with a long rising and short falling shape would have a lower peak shape number.

### ECHO

The ECHO method was implemented using the `echo.find()` function, from the package of the same name.

ECHO requires sample series to be in rows, with replicates ordered by time point as columns. The original table is not in this format, so some initial pivoting is required first.

```{r ions-echo-table}
ions_echo_table <- pivot_longer(ion_abundance, cols = -c(Time, Condition), names_to = "Ion", values_to = "Abundance") %>%
  drop_na() %>%
  separate_wider_delim(cols = "Ion", delim = "_", names = c("Ion", "Replicate")) %>%
  select(-Condition) %>%
  pivot_wider(names_from = c("Time", "Replicate"), values_from = c("Abundance")) # get values in right format

ions_echo_table
```

Once the data is in the correct format for ECHO, the function can be run on the LD and LL data. All parameters were kept the same as those known to have been applied to the proteome in [Kay *et al.* (2021)](https://doi.org/10.1038/s42003-021-02680-3) to better facilitate comparison of the results, except where changes were necessary to reflect differences in sampling (i.e. `resol = 2` because the ion abundance samples were taken 2 hours apart, `num_reps = 4` because there are 4 replicates for each ion).

```{r run-echo-for-ions}
ions_echo_LD <- select(ions_echo_table, Ion, "0_1":"24_4") %>%
  echo_find(
    begin = 0, end = 24, resol = 2, num_reps = 4, low = 24, high = 24, run_all_per = FALSE,
    paired = FALSE, rem_unexpr = FALSE, is_normal = FALSE, is_de_linear_trend = FALSE,
    is_smooth = FALSE
  ) %>%
  rename(Ion = "Gene Name") # run echo for relevant time points

ions_echo_LL <- select(ions_echo_table, Ion, "48_1":"96_4") %>%
  echo_find(
    begin = 48, end = 96, resol = 2, num_reps = 4, low = 20, high = 28, run_all_per = FALSE,
    paired = FALSE, rem_unexpr = FALSE, is_normal = FALSE, is_de_linear_trend = TRUE,
    is_smooth = FALSE
  ) %>%
  rename(Ion = "Gene Name") # run echo for relevant time points

ions_echo_LD
ions_echo_LL

select(ions_echo_LD, "Ion", "Oscillation Type", "Period", "P-Value":"BY Adj P-Value") # view results
select(ions_echo_LL, "Ion", "Oscillation Type", "Period","P-Value":"BY Adj P-Value") # view results
```

This has identified K as most significantly rhythmic in LD conditions, followed by Ca (and determines that Mg is not significantly rhythmic in LD at the *p* \< 0.05 threshold). Mg and Ca are assigned a repressed oscillation type (where the amplitude decreases considerably over time), while K is labelled a harmonic oscillation (where amplitude remains mostly the same over time).\
Conversely, all three ions are once again identified as rhythmic in LL conditions (except Ca but only when the *p*-value is adjusted using the BY method), though much more significantly for Mg and K versus Ca. Mg and K are assigned a damped oscillation type, where the amplitude of the rhythm decreases with time, while Ca is assigned an overexpressed oscillation type, which is the opposite (amplitude increases with time, to the point ECHO no longer counts it as circadian). The period of Mg is longer than Ca or K.

ECHO fits the original time points to the assigned oscillation type's differential equation, so I want to see how this fit is different to the original samples.

```{r echo-fit-data}
ions_echo_LL_ori <- select(ions_echo_LL, "Ion", starts_with("Original")) %>% rename_with(~ str_remove(., "Original TP"), everything()) %>% # get relevant columns
  pivot_longer(cols = !"Ion", names_to = "Time", values_to = "Abundance")
# This has 4 rows per time point, so I need to get the mean
ions_echo_LL_ori$Time <- str_remove(ions_echo_LL_ori$Time, "\\..*")
ions_echo_LL_ori <- ions_echo_LL_ori %>%
  group_by(Ion, Time) %>%
  summarise(across(), mean = mean(Abundance)) %>%
  distinct(Ion, Time, mean) %>%
  pivot_wider(names_from = "Ion", values_from = "mean") %>%
  ungroup() # pivot to plot


ions_echo_LL_fit <- select(ions_echo_LL, "Ion", starts_with("Fitted")) %>%
  rename_with(~ str_remove(., "Fitted TP"), everything()) %>% # get relevant columns
  pivot_longer(cols = !"Ion", names_to = "Time", values_to = "Abundance") %>%
  pivot_wider(names_from = "Ion", values_from = "Abundance") # pivot to plot

ions_echo_LL_ori
ions_echo_LL_fit
```

```{r plot-echo-fit-data}
ions_echo_LL_to_plot <- left_join(ions_echo_LL_ori, ions_echo_LL_fit,
  by = "Time",
  suffix = c("_Original", "_Fitted")
)
ions_echo_LL_to_plot

echo_plot_data <- ions_echo_LL_to_plot %>% 
  pivot_longer(cols = !Time, names_to = "Ion", values_to = "Abundance") %>%
  separate_wider_delim(cols = Ion, delim = "_", names = c("Ion", "Status")) %>%
  group_by(Ion, Status) %>%
  mutate(zero_one = ((Abundance - min(Abundance)) /
    (max(Abundance) - min(Abundance))))

echo_plot_data

echo_plot <- ggplot(data = echo_plot_data, 
                    aes(x = Time, y = zero_one, group = interaction(Ion, Status),
                    colour = interaction(Ion, Status))) +
  geom_line(linewidth = 0.8) +
  geom_point() +
  geom_point(colour = "black", shape = 21)

echo_plot
```

### Saving/loading results

For the Shiny tool, I have chosen to save these calculated rhythmicity values for the ions to their own Excel spreadsheet (similar to the one that exists for the proteome), as they do not need to be re-calculated every time the tool is launched.

```{r save-ion-rhythmicity, eval=FALSE, include=FALSE}
ion_rhythmicity <- list(ions_rain_LD, ions_rain_LL, ions_echo_LD, ions_echo_LL) # get values as list
names(ion_rhythmicity) <- c("ions_rain_LD", "ions_rain_LL", "ions_echo_LD", "ions_echo_LL")
write_xlsx(ion_rhythmicity, "ion_rhythmicity.xlsx") # write each table of values to its own sheet
```

These are then loaded in from this spreadsheet when the tool is first launched, in a similar way to the protein datasets.

```{r load-ion-rhythmicity}
ion_rhythmicity <- "ion_rhythmicity.xlsx" # set file name in tool
ion_rhythmicity <- ion_rhythmicity %>%
  excel_sheets() %>% # get name of sheets from the file
  set_names() %>% # set names of each variable to name of sheet
  map(read_excel, path = ion_rhythmicity) %>% # create list of pre-calculated outputs
  list2env(.GlobalEnv) # allow each output to be accessed individually, like how they went into the raw excel file in the first place
```

------------------------------------------------------------------------

# Comparing protein/ion phases

This chunk plots the phases of all proteins that are rhythmic in LL according to both RAIN and ECHO.

```{r plot-phase-graph}
ion_phases <- select(ions_rain_LL, Ion, phase) %>% filter(Ion != "Time")
protein_phases <- select(double_rhythmics_full, Identifier, phase = Circadian_Phase_LL)

ion_phases
protein_phases

protein_phases <- protein_phases %>% mutate(
  phase_vs_Mg = phase - 12,
  phase_vs_K = phase - 10
)

count(protein_phases, phase_vs_Mg, sort = TRUE)

protein_phases

phase_plot <- ggplot(data = protein_phases) +
  geom_freqpoly(aes(x = phase_vs_Mg), binwidth = 0.5) +
  xlim(-12, 12)

phase_plot # plot
```

Setting up a graph of traces vs. phases of the Mg-binding rhythmic proteins:

```{r trace-peak-setup}
ion_data <- ion_abundance # create table with all necessary columns
ion_data <- pivot_longer(ion_data, cols = -c(Time, Condition), names_to = "Ion", values_to = "Abundance") %>% drop_na()
ion_data$Ion <- str_remove(ion_data$Ion, "\\_.*") # clean up ion names
ion_data <- mutate(ion_data,
  Condition = case_when(ion_data$Time <= 24 ~ "LD", ion_data$Time >= 48 ~ "LL"),
  .after = Time
) # add condition column
ion_data <- ion_data %>%
  group_by(Time, Condition, Ion) %>%
  summarise(across(), mean = mean(Abundance), sd = sd(Abundance)) %>%
  group_by(Ion) %>%
  mutate(rel_abun = mean / max(mean)) # add other/stats columns

ion_data <- ion_data %>%
  filter(Ion != "Ca") # take out calcium because that's not really rhythmic

rhythmic_abundance <- select(rhythmic_ion_binders_full, "Identifier", "48":"121.5") %>%
  pivot_longer(cols = !Identifier, names_to = "Time", values_to = "Abundance") # set up initial table of abundance values
rhythmic_abundance

peak_times <- rhythmic_abundance %>%
  group_by(Identifier) %>%
  mutate(Time = case_when(Abundance == max(Abundance) ~ as.numeric(Time))) %>%
  ungroup() %>%
  distinct(Identifier, Time, .keep_all = TRUE) %>%
  drop_na() %>%
  mutate(zero_one = ((Abundance - min(Abundance)) /
    (max(Abundance) - min(Abundance)))) # get maximum abundance for all 16

peak_times


peaks <- select(rhythmic_ion_binders, Identifier, Absolute_Phase_LL) %>%
  mutate(
    phase_day_1 = Absolute_Phase_LL + 48,
    phase_day_2 = Absolute_Phase_LL + 72
  )

peaks
```

```{r trace-peaks-graph}

trace_peaks_graph <- ggplot(data = ion_data,
  aes(x = Time, y = rel_abun, colour = Ion, group = Ion)) +
  
  geom_rect(data = time_shading,
                aes(y = NULL, group = NULL, colour = NULL,
                    xmin = Time, xmax = Time + 1, ymin = -Inf, ymax = Inf, 
                    fill = colour), 
                show.legend = FALSE) + # set up background
      scale_fill_identity(time_shading$colour) + # shade appropriately
      new_scale_fill() + # let rest of graph use new shading 
  
  geom_line(linewidth = 0.8) +
  geom_point() +
  geom_point(shape = 21, colour = "black") + # plot ion traces
  
  geom_point(data = peak_times,
    aes(x = Time, y = 1, group = NULL),
    colour = "black", shape = 4, size = 3) + # plot peak times

  theme_bw() +
  
  scale_x_continuous(breaks = scales::breaks_width(12), minor_breaks = NULL,
                     limits = c(48, 96) # limit only to LL
  )

trace_peaks_graph # show graph
```

```{r circular-mg-heatmap}
# like AB's figure in multiomics
circ_heatmap_data <- select(interped_heatmap_data, 
                            "Identifier", "Time", "Abundance", "zero_one") %>%
  group_by(Identifier) %>%
  mutate(peak_time = Time[Abundance == max(Abundance)]) %>%
  ungroup()
  
circ_heatmap_data # view 

circ_heatmap <- ggplot(data = circ_heatmap_data, 
                       aes(x = Time, 
                           y = fct_reorder(Identifier, peak_time, .desc = TRUE),
                       fill = zero_one)) +
  geom_tile() +
    
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title = element_text(size = 12)
  ) +
  scale_x_continuous(breaks = scales::breaks_width(12)) +
  scale_fill_viridis(option = "D") +
  
  labs(x = "Time", y = "Identifier", fill = "Normalised\nabundance") +
  
  coord_radial(inner.radius = 0.6, expand = FALSE) # make circular

circ_heatmap
```

```{r multiday-heatmap}
# My attempts to stack all three days on top of each other for the heatmap
# initial mutate line goes from 1 to 4 due to timepoints >= 120

multiday_data <- circ_heatmap_data %>%
  mutate(Day = (Time %/% 24) - 1, 
         ZT = Time %% 24, .after = Time) %>%
  filter(Day <= 3, .preserve = TRUE) %>% # remove timepoints after 120 for plotting
  unite(col = "ID_day", Identifier, Day, sep = "_", remove = FALSE) %>%
  
  group_by(ID_day) %>%
  mutate(peak_time = ZT[Abundance == max(Abundance)],
         zero_one = ((Abundance - min(Abundance)) /
      (max(Abundance) - min(Abundance)))
      ) %>% # recalculate 0-1 normalisation and peak time per day
  ungroup() 

multiday_heatmap <- ggplot(data = multiday_data, 
                       aes(x = ZT, 
                           y = fct_reorder2(ID_day, peak_time, Identifier, .desc = TRUE),
                       fill = zero_one)) +
  geom_tile() +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title = element_text(size = 12)
  ) +
  scale_x_continuous(breaks = scales::breaks_width(1)) +
  scale_fill_viridis(option = "D") +
  labs(x = "ZT", y = NULL, fill = "Normalised\nabundance")

multiday_heatmap

multiday_heatmap_circ <- ggplot(data = multiday_data, 
                       aes(x = ZT, 
                           y = fct_reorder2(ID_day, Identifier, peak_time, .desc = TRUE),
                       fill = zero_one)) +
  #geom_tile() +
  geom_rect(aes(xmin = ZT, xmax = ZT + 0.5, 
                ymin = stage(ID_day, after_scale = ymin-1),
                ymax = stage(ID_day, after_scale = ymax))
            ) +
  geom_vline(xintercept = c(0, 12), linewidth = 0.1, alpha = 0.5) + # check the axes aren't skewed
    
  theme_bw() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        axis.title = element_text(size = 12)
  ) +
  scale_x_continuous(expand = c(0, 0), breaks = scales::breaks_width(1)) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_viridis(option = "D") +
    
  coord_radial(inner.radius = 0.6, expand = FALSE) + # make circular
    
  labs(x = "ZT", y = NULL, fill = "Normalised\nabundance")

multiday_heatmap_circ
```

==

```{r end}
print("End chunk")
```
